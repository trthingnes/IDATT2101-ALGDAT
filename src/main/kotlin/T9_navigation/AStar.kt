package T9_navigation

import java.util.*

class AStar {
    /**
     * Runs the ALT (A*, Landmarks, Triangular eq.) algorithm on the given graph.
     * @param n The number of nodes in the graph.
     * @param edges The edges in the graph, as a list of arrays on form (from, to, cost).
     * @param landmarksData Distances to and from all landmarks generated by the [Preprocessor].
     * @param start The number of the node to start the search from.
     * @param end The number of the node to end the search in. If omitted, finds all nodes.
     * @return An array representing the route taken on form {(firstNode, cost), (secondNode, cost),...}
     */
    fun alt(n: Int, edges: List<Array<Int>>, landmarksData: Array<Array<Array<Int>>>, start: Int, end: Int): Array<Pair<Int, Int>?> {
        val lmFrom = landmarksData[0]
        val lmTo = landmarksData[1]

        val path = arrayListOf<Pair<Int, Int>>()
        val nodes = Array(n) { Node(it) }

        edges.forEach {
            nodes[it[0]].neighbours.add(Pair(nodes[it[1]], it[2]))
        }

        nodes[start].cost = 0
        nodes[start].visited = true


        // Create a queue that prioritizes low distance.
        val queue = PriorityQueue<Node>() { a, b -> a.priority - b.priority }
        queue.add(nodes[start])

        // While there are undiscovered nodes.
        while(queue.isNotEmpty()) {
            val node = queue.poll()

            //For every neighbour node that is not visited.
            node.neighbours.forEach {
                val neighbour = it.first
                val cost = it.second

                // Set the neighbour as visited and update the costs.
                if (neighbour.cost > neighbour.cost + cost){
                    neighbour.cost = node.cost + cost
                    neighbour.weight = calculateDistance(lmFrom, lmTo, neighbour.number, end)
                    neighbour.previous = node
                    queue.remove(neighbour)
                    queue.add(neighbour)
                }
            }
            node.visited = true
        }

        val result = arrayListOf<Pair<Int, Int>?>()
        result.add(Pair(nodes[start].number, 0))
        nodes.forEach {
            if (it.previous == null) result.add(null)
            else result.add(Pair(it.previous!!.number, it.cost))
        }
        return result.toTypedArray()
    }

    /**
     * Uses the triangular equation to calculate the distance from the given node to the end.
     * @param lmFrom Distances to all nodes from all landmarks.
     * @param lmTo Distances from all nodes to all landmarks.
     * @param node The node to measure distance from.
     * @param end The node to measure distance to.
     * @return A positive integer representing the distance from node to end.
     */
    private fun calculateDistance(lmFrom: Array<Array<Int>>, lmTo: Array<Array<Int>>, node: Int, end: Int): Int {
        var best = 0

        for(i in lmFrom.indices) {
            val distFrom = lmFrom[i][end] - lmFrom[i][node]
            val distTo = lmTo[i][node] - lmTo[i][end]

            if(distFrom > best) best = distFrom
            if(distTo > best) best = distTo
        }

        return best
    }

    class Node(
        val number: Int,
        val neighbours: ArrayList<Pair<Node, Int>> = arrayListOf(), // Pair(node, cost)
        var visited: Boolean = false,
        var previous: Node? = null,
        var weight: Int = Int.MAX_VALUE,
        var cost: Int = Int.MAX_VALUE
    ) {
        val priority get() = weight + cost
    }
}